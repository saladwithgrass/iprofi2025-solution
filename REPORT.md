# Задача
На соревновании Я Профи в этом году задачей было написание системы автономного
управления машиной с RGBD-камерой и системой позиционирования GNSS-RTK.

# Что есть на руках
## RGBD камера
RGBD камера дает облако точек с цветами и расстояниями до камеры. Через
некотрые преобразования данных с камеры, можно получить реальеф местности и
цвета относительно некоторой точки, закрепленной на машине.

## GNSS-RTK 
Данная система дает положение относительно какой-то заранее заданной
стационарной точки. Быстрый поиск говорит, что данная система позиционирования
дает точность до сантиметра
https://en.wikipedia.org/wiki/Real-time_kinematic_positioning.

## Управление газом
Управление газ/тормоз реализовано так, что мы подаем процент от максимального
момента на колесах, а двигатели его исполняют.
Процент может быть как положительным, так и отрицательным, то есть по сути
тормоза нет, есть только газ назад, что позволяет делать управление скоростью
гораздо проще.

## Управление рулем
Тут просто задается угол поворота передних колес в диапазоне от -0.6 до 0.6.

## Системы координат
Есть глобальная система координат, которой в рамках этой работы можно
пренебречь, не считая одного момента. 
Так как задача --- проехать как можно дальше, машина должна ехать вперед,
направление движения задается изначальным положением машины. 
Я выяснил, что ось X машины направлена "вперед", то есть, можно сказать, по
направлению взгляда водителя. Ось Y направлена влево, а ось Z --- вверх. 

# Разбиваем задачу 
Итак, теперь, узнав, что есть на руках, нужно построить
архитектуру решения данной задачи.

## Обработка данных с камеры (класс Lidar)
Данными с камер является облако точек, описывающее
рельеф местности и его цвета. Нужно перенести эти данные в систему координат
машины из СК камеры и выделить точки, принадлежащие дороге.

## Картография (класс Mapper)
Так как машина может иметь любое положение, точки дороги и ее
центр могут лежать не прямо перед машиной, машина должна "помнить" точки,
которые уже "увидела". 
При этом, не нужно ехать туда, где машина уже была. Таким образом, нужен модуль
который будет строить карту местности, а также запоминать места, где машина уже
была.
Также, картограф должен выделять потенциальные точки, куда машине нужно ехать.



## Модуль направления (класс Director)
Нужен модуль, который на основе данных с карты будет строить траекторию, по
которой нужно ехать или выделять точку, куда машине нужно ехать.
Также, так случилось, что в моей реализации, Директор также задает скорость и
вводит меры предотвращения заносов, однако по-хорошему, это должны быть
отдельные модули.

## Контроллер(ы) машины 
Машиной нужно как-то управлять на основе заданной точки или траектории движения.
Я рассматривал два варианта:
1) MPC контроллер для следования по траектории.
2) Pure Pursuit + PID контроллеры для движения в заданную точку.

### Model Predictive Control
Когда выложили демо версию, это была первая идея для управления машиной.
Идея этого контроллера заключается в том, что если у нас есть модель какой-то
системы, то нам нужно найти такой набор сигналов управления, чтобы
минимизировать ошибку на ближайших n шагах, выбрать первый сигнал, а потом
найти следующий набор.

### Pure Pursuit 
Это самый простой контроллер для машины. Он основывается на велосипедной модели машины.
У Pure Pursuit есть Lookahead расстояние. Мы берем точку траектории, лежащей на
этом расстоянии от машины, передаем ее на Pure Pursuit контроллер и он
геометрически расчитывает на сколько нужно повернуть руль, чтобы оказаться в этой точке.
Этот контроллер крайне прост в реализации, однако может иметь проблемы при
сильных возмущениях системы.

### Proportional Integral Differential регулятор
PID-регулятор является классикой в мире управления. Простой и надежный, хоть и
не оптимальный. В своей работе я его использовал для того, чтобы поддерживать
какую-то постоянную скорость. Чтобы этот контроллер работал не нужно даже иметь
модель системы, достаточно лишь правильно подобрать веса.

# Реализация архитектуры
Итак, имея на руках общую архитектуру решения данной задачи, теперь рассмотрим
как я ее реализовал.

# Обработка данных с камеры

## Предобработка
Мы получаем облако точек, содержащее 3Д координаты и цвета. 
Первым делом, может иметь смысл очистить это облако от точек, у которых есть
NaN в какой-либо из координат, ибо они не принесут пользы.
Однако, если нужна обработка всей картинки, то лучше не очищать его, чтобы
картинка сохранила свое разрешение.

Еще одна вещь для уменьшения объема данных --- обрезка по высоте. Очевидно, что
если машина в данный момент имеет координату Z = 1,
то точки, которые на, скажем, 3 метра выше --- точно не дорога.

## Перевод координат
Для начала, стоит разобраться как переводить точки из системы координат камеры
в систему координат машины. Так как доступен RViz, в нем можно посмотреть
положение камеры и ее поворот. Получаем однородную матрицу перехода, после чего
достаточно ее инвертировать и применить ко всем точкам.

## Выделение дороги
На этом этапе у меня было две идеи о том, как это можно реализовать.
### Нормали
Дороги по которым ездят машины не имеют большой наклон. Где-то я слышал, что
дорога с самым большим наклоном имеет наклон 17 градусов. Соответственно,
разумно предположить в данных соревнованиях наклон дороги не будет рекордным.
Также у библиотеки Open3D есть отличная функция для оценки нормалей облака
точек. Соответственно, если мы оценим нормали всего что видим, и выберем точки,
где нормаль отклоняется от вертикальной меньше чем на 17 градусов, мы сильно
уменьшим объем данных и оставим дорогу + случайные точки. 
Также, чтобы ускорить вычисления, имеет смысл уменьшить количество точек при
помощи даунсэмплинга, благо в Open3D есть встроенная функция downsample.

Однако, нужно также как-то еще обработать точки, чтобы убрать точки, которые
принадлежат пологим поверхностям, но при этом не являются дорогой.
Были эксперименты с цветом, но проще и быстрее оказалось использовать только цвет.

### Цвет
Еще одна из опций --- выделить дорогу визуально. У меня нет на руках ни
подходящего железа, ни опыта работы с нейросетями, необходимого для
использования нейросетевых методовы сегментации дороги.
Тогда будем двигаться от того, что я могу.
У меня есть относительно обширный опыт работы с OpenCV, что мне здорово помогло.

Для начала рассмотрим имеющиеся данные. Базово, я имею картинку с камеры в
цветовом пространстве RGB. Несмотря на свою популярность в компьютерной сфере,
я бы не хотел использовать это пространство потому что для человека оно
малоинформативно. Сначала, конечно, я пытался как-то покрутить фильтр в RGB, но
это не увенчалось успехом, ибо RGB просто не удобен для подобных вещей. Но с
другой стороны, это не единственное доступное цветовое пространство, есть
множество других: HSV, HSL, OKLab, YCbCr и другие. HSV как раз идеально
подходит для моей задачи.
Переведя изображение в HSV и отрисовав все три канала по отдельности, я
моментально заметил, что дорога крайне выделяется по своему оттенку (Hue).
Ровно это я и искал, дорогу можно достаточно надежно выделять по ее оттенку.

Подобрав хорошие значения, я применил пороговый фильтр на изображение по каналу
Hue, в результате чего, почти вся дорога стала черной, а все остальное ---
белым. Инвертировав изображение, я получил картинку, где дорога белая, а все
остальное стало черным. Теперь чтобы убрать небольшие шумы и выбросы, я
прошелся по изображению фильтром dilate, чтобы чуть сильнее распространить
белый цвет и все. Дорога выделена. Теперь соотносим точки на картинке с точками
в облаке точек, уменьшаем объем облака и отправляем дальше.

# Картография
Чтобы как можно более корректно определять куда машине нужно ехать в данный
момент, стоит иметь карту дороги, то есть помнить все точки, распознанные как
дорогу.

Так как обработка данных с камеры передает облако точек, которое было
задаунсэмплено при помощи вокселей с заданным размером, мы можем легко
перевести эти точки на картинку.

Класс Mapper по сути представляет собой обертку вокруг одной картинки в
grayscale формате.

## Почему так?
Перенос реальных координат на сетку --- практика крайне распространенная,
достаточно взглянуть на сообщение OccupancyGrid в ROS или посмотреть на то, как
иллюстрируются алгоритмы поиска пути.

Помимо этого, OpenCV предоставляет очень удобную работу с изображениями и его будет использовать удобно для обработки карты. 


Как только картограф получает список точек принадлежащих дороге, он совершает
## 1) Перевод "реальных" координат в индексы пикселей на картинке.
У картографа есть центр отсчета в реальных координатах. В идеале, эта точка
находится по центру карты. Также, необходимо правильно отмасштабировать
точки. 
Допустим, картограф работает с разрешением 1 пиксель <==> 0.1 метр и имеет центр (x, y). 
Введем переменные, соответствующие этим параметрам:
```python
origin = (x,y)
resolution = 0.1
```
Отметим, что `resolution` здесь соответствует длине одного пикселя в метрах.
Тогда перевод точек из реальной системы отсчета на карту будет выглядеть так:
```python
points_mapped = (points_xy - origin) / resolution
```
Это и обратное преобразования были описаны в файле `utils.py`.

## 2.1) Обновление карты
Сначала нужно обрезать полученные в предыдущем пункте индексы,
чтобы они не вылезли за пределы картинки и не случилось `undefined
behaviour`. 
```python
def update_map(self, map_points):
    map_points = map_points[map_points[:, 0] >= 0]
    map_points = map_points[map_points[:, 0] < self.map_data.shape[0]]
    map_points = map_points[map_points[:, 1] >= 0]
    map_points = map_points[map_points[:, 1] < self.map_data.shape[1]]
    ...
```
Можно заметить, что в текущей реализации, если точки находятся вне пределов
карты, они просто обрезаются. Это **ОЧЕНЬ** плохое решение, в идеале нужно
карту расширять по мере необходимости.

После этого, маппер просто проходится по всем точкам, которые были выбраны и добавляет к ним 1, если из значение не является крайним(иначе случится integer overlow)
```python
        ...
        for point in map_points:
            if self.map_data[point[0], point[1]] < 255:
                self.map_data[point[0], point[1]] += 1
```
Увеличивать значение на 1, а не делать его максимальным сразу же дает данному алгоритму легкие антишумовые свойста:
Чем больше раз точка была распознана как дорога, тем больше вероятность, что
это действительно дорога. И 
значение в ячейке карты это отражает.

## 2.1) Обновление известных мест.
Также, чтобы отсекать точки, в которых машина уже побывала, нужно обновлять
карту известных мест. Для этого у Картографа есть поле `visited`,
представляющее собой grayscale-картинку, заполненную занчениями 255.
Как только приходят данные с новым(или не очень) кусочком карты, картограф
также закрашивает черный круг с радиусом 4 метра и центром в цетре машины на этом
поле.



## 3) Выделить регион интереса (ROI)
После того, как карта была обновлена, необходимо опубликовать данные.
Чтобы уменьшить объем передаваемой информации и оставить только необходимое, нужно выбрать ROI --- Region Of Interest для машины.
Здесь в качестве ROI используется круг радиусом 40 метров.
Для получения области интереса, у Картографа есть функция `get_roi`.


Для начала нужно перевести текущее положение машины в индекс карты, для этого используем `points_to_map`.
После этого, выбираем прямоугольник с центром этой точке и стороной, равной
отмасштабированному радиусу(в моем случае, он равен 400 пикселей), для чего просто формируем индексы его углов.
После этого, применяем оператор `bitwise and` на карту дороги и карту известных точек, получаем только неизвестные точки дороги и из них выделяем ROI.

Выбрав нужные точки, переводим их в реальные координаты, формируем
OccupancyGrid сообщение и публикуем на соответствующий топик.

# Направление
Итак, теперь самый главный модуль, можно сказать мозг всей системы.
Класс `Director`.

Так как он был подвержен переработкам и рефакторингу больше всего, это
пожалуй самый грязный модуль в моей работе, однако функции свои он выполняет,
чего достаточно.

Чтобы было проще понять его прицип работы, можно разбить его на несколько ключевых функций.

## Обработка карты дороги
Директор обрабатывает только область интереса, полученную с Картографа.
Для начала, чтобы заполнить пустые точки посреди дороги, которые могли
образоваться, стоит пройтись фильтром dilate с каким-нибудь не очень большим
ядром(я использовал 5px, то есть максимальный размер "дыры" в дороге --- что-то порядка 0.5--0.7 метров). Это как заполнит черные точки внутри дороги, так и расширит ее. Последнего мы не хотим, поэтому сузим ее обратно через erode.
В начале я пытался сузить дорогу примерно до ее измеренной ширины(примерно
4.8 метра), чего можно добиться через правильный подбор размера ядра.
Однако, это давало не очень хорошие результаты, поэтому я сужаю дорогу с эмпирически подобранным размером ядра, который меньше ширины дороги.

После этого применяем порог, чтобы отсечь значения, которые были замечены меньше какого-то количества раз. В своей работе я использовал 6 раз как пороговое значение.

Таким образом, в регионе интереса у нас оказывается кусочек, полностью
закрашенной дороги, которая со значительной вероятностью является дорогой на самом деле.

## Выбор целевой точки
Так как я решил использовать Pure Pursuit контроллер для задания поворота
руля, на каждом шаге мне необходимо выбирать какую-то точку на заданой
траектории.

Допустим, у нас уже определено расстояние `lookahead`. Тогда, если мы
проведем окружность, центр которой находится в центре машины, то его
пересечения будут точками траектории, лежащими ровно на этом расстоянии.

Как жаль, что нужно провести много сложных геометрических расчетов...
Или просто нарисовать круг при помощи OpenCV и применить его как маску к
изображению.

На каждом своем шаге, Директор, в зависимости от скорости машины обновляет
изображение с окружностью так, чтобы окружность была правильного радиуса.
Радиус зависит от скорости: чем больше скорость, тем больше `lookahead`.

У Директора есть функция `get_possible_targets`, которая применяет маску `lookahead_circle` к текущему ROI.

Также, в случае, если директор не нашел точек с текущим `lookahead`, он
увеличивает его в попытках найти хоть какие-то точки. 
```
        while not possible_targets.any() and self.lookahead < 12.5:
            self.lookahead += 1
            self.update_lookahead_circle()
            possible_targets = self.get_possible_targets(data)
```

После этого следует кусочек, который не дает машине полностью завершить круг:
```
        if not possible_targets.any():
            self.get_logger().fatal('NO POINTS IN PROXIMITY')
            if self.last_target is None:
                return
            else:
                point_local = self.last_target
```
Тут видно, что если точек не нашлось в ROI, то Директор как целевую точку передает последнюю известную цель.
Однако, как известно, картограф просто закрашивает места, где машина уже
побывала, поэтому если оказаться там, где машина уже проехала, то ROI будет
пустым, а Директор не сможет найти целевую точку.

Итак, применение `lookahead` это по сути своей `bitwise and` между двумя изображениями:
- Круга определенной толщины и радиуса, соответствующего `lookahead`
- Изображения текущего ROI, где отмечены точки, которые еще не были посещены.

Получаем набор точек на дороге, которые лежат на расстоянии, близком к `lookahead`. Усредняем и получим целевую точку, после чего переводим ее в реальные координаты.
Теперь стоит расчитать расстояние до этой точки и на основе этого при помщи Pure Pursuit получить угол поворота.
Когда я писал эту работу, я не сделал этого. Почему? Понятия не имею, очень
тупо получилось, я просто считал угол с заранее заданным `lookahead`.

## Предотвращение застреваний
Так как каждый класс имеет в себе историю(чтобы чуть лучше обращаться с задержкой), я могу оценить двигалась ли машина в последнее время.

Для этого найдем среднее значение среди последних 100 значений:
```python
        # check if car has been moving recently
        if abs(vel[0]) < 0.1 or self.stuck_counter > 0:
            # get average velocity over some time
            recent_vels = self.hist_keeper.get_latest_n_data(100, True)
            recent_vels = np.linalg.norm(recent_vels, axis=1)
            weights = np.exp(np.linspace(1, 0, len(recent_vels)))
            avg = np.average(recent_vels, weights=weights)
            ...
```
Если это значение мало и при этом машина не находится в "режиме отъезда", то просто включаем режим отъезда:
```python
            ...
            if avg < 0.2 or self.stuck_counter > 0:
                if self.stuck_counter == 0:
                    self.stuck_counter = 10
                self.stuck_counter -= 1

                self.steering_angle = self.get_angle([1, 0], point_local)

                self.get_logger().warning('IM STUCK')
                self.publish_angle_control(self.steering_angle)
                self.publish_target_velocity(-1.5)
                return
```

## Предотвращение заносов
За время тестирования, я заметил, что дорога **очень** скользкая. 
Как с этим бороться?
Один из вариантов --- учесть это в фундаментальном алгоритме управления. Если
бы машина управлялась через MPC, то вероятно, заносы учитывались бы там. Я
пытался сделать модель с заносом, но уже не было времени тюнитьь ее.

Другой вариант --- распознать то, что происходит занос и попытаться предотвратить его. Умными действиями было бы почитать про то, как реальные водители выходят из заносов и попытаться это повторить. Однако опять же, так как времени было мало я прикинул что нужно сделать и имплементировал это.
Итак, первая вещь, которую я сделал --- проверка того, нужно ли вообще что-то делать. Мне показалось, что при малых скоростях, можно и не пытаться предотвратить занос. Поэтому сначала проверяется, больше ли скорость 0.5 м/с по модулю.
Если скорость больше, то вызывается функция `deal_with_yaw_rate`.
### Проверка на занос
Это скорее проверка на потерю управляемости.
Я выделил несколько условий, при выполнении которых не нужно противодействовать заносу:
1) Если знак желаемого угла и текущей скорости поворота совпадают, то машина едет куда нужно, все ОК.
2) Если ошибка между желаемой скоростью и целевой мала, то все ОК.
3) Если мы едем назад, что происходит только когда машина отъезжает, чтобы выровняться, то не нужно противодействовать "заносу".

### Противодействие заносу
Тут я решил использовать что-то крайне простое. Как только машина замечает занос, она попытается поехать в обратную сторону с вывернутым в обратную сторону рулем. Это не идеал, но этого хватает.

На этом собственно все. Машина едет.
